/**
 * JavaCC grammar: 
 */

options
{
  STATIC = false;
  LOOKAHEAD = 2;
}

PARSER_BEGIN(Grammar)

package parser;
	import java.util.HashMap;
	import java.util.HashSet;
	import java.util.LinkedList;
	import token.*;

    public class Grammar {

	public HashMap<String, Integer> functionSymbols; /* Identify the arity of a function */
	public static int numberOfEquation; /* Number of equations */
	public static HashSet<String> constantSet;	/* Set of constant symbols */
	public static HashSet<String> variableSet; 	/* Set of variable symbols */ 
	public String to_select;
	public String selected;	

	public Grammar(String input, String to_select, String selected) {
	  	this.functionSymbols = new HashMap<String,Integer>();
	  	this.numberOfEquation = 0;
	  	this.constantSet = new HashSet<String>();
	  	this.variableSet = new HashSet<String>();
	  	
		this.to_select = to_select;
		this.selected = selected;

      	try {
        	new Grammar(new java.io.StringReader(input)).START();
      	} catch(Exception e) {
      	  System.out.println("Oops: syntax error, check the formula!"+e.getMessage());
          System.exit(-1);
        }
    }
}

PARSER_END(Grammar)

SKIP:  { " " | "\t" | "\n" | "\r" | <"%" (~["\n","\r"])* ("\n" | "\r" | "\r\n")?> } /* "Skip characters": we don't parse them */
<*>TOKEN: {
  			<NOT:				"!"> /* Negation: in this project we have only one predicate, the equal predicate */	
		| 	<SEMICOLON:			";"> /* Semicolon: used to identify the end of an equation */
		|   <DOLLAR:			"$"> /* Dollar: used to identify the end of the set of the equations */
		| 	<COMMA:				"," > /* Comma: used to separate the function's parameters */
        |   <EQUALS:            "="> /* Equal predicate: the only predicate in this project */
        |   <LOWER_WORD:        ( <LOWER_ALFA> ) ( <LOWER_ALFA> ) ( <LOWER_ALFA> )* > /* Function symbols: for hypothesis, we use at least two letters (without numbers) for a function symbol */
        |   <UPPER_WORD:        ( <UPPER_ALFA> ) ( <NUMERIC> )* >   /* Variable symbol: for hypothesis, we use at least a upper character and a (optional) digit for a variable symbols */
	
        |   <LOWER_ALFA:       ["a"-"z"]>	/* Lower character */
        |   <#UPPER_ALFA:       ["A"-"Z"]>	/* Upper character */

        |   <NUMERIC:          ["0"-"9"]>	/* Digit */         
        |   <#ZERO_NUMERIC:     ["0"]>		/* Zero */
        |   <#NON_ZERO_NUMERIC: ["1"-"9"]>	/* Non-zero digit */
        }

/*
void LITERAL():
{
  Token sign=null;
  Token p;
  LinkedList<Term> args=new LinkedList<Term >(); 
}
{
  (sign=<NOT>)? (p=<LOWER_WORD>)?
  {
    int weight=1;
     //it is a predicate with arguments, check if I've already read it with
      //a different number of arguments
      Predicate p2 = tmpPred.get(p.image);
      
      if( p2 != null && p2.getArgsCount() != args.size() )
      {
       throw new ParseException("The predicate \"" + p.image 
                        + "\" has been already read with " + p2.getArgsCount() + " argument(s)"); 
      }
      
      for(Term t:args) // retrive the weight of my arguments
      {
        weight += t.getWeight();
      }
    Predicate newPred = new Predicate(p.image,weight,args, (sign==null) ? false:true);
    tmpPred.put(p.image,newPred);
    return newPred;
  }
}
*/

/* Parser entry point */
void START(): {}
{
  
    (EQUATION())+ <DOLLAR>	/* We identify an unbounded numbers of equation (followed by a dollar symbol)*/

}

Equation EQUATION():
{
	Term t1;
	Term t2;
}
{
	/* An equation is a term equals to another term (with the negation sign optional) */
    (t1 = TERM()) (<NOT>)? <EQUALS>  ( t2 = TERM()) <SEMICOLON>
    {
      	numberOfEquation++;
      	return new Equation(t1, t2);
    }
    
}

Term TERM():
{
	Token c;
	Token x;
	Token f;
	LinkedList<Term> list;
}
{
  
 	/* A term is a variable, a constant or at least two lower letter followed by the arguments*/
 	  ( x = <UPPER_WORD>) { return new Variable(x.toString()); }
 	| ( c = <LOWER_ALFA> ) { return new Constant(c.toString()); }
 	| ( f = <LOWER_WORD>) "(" list = ARGUMENTS() ")" { return new Function(f.toString(), list); }

}

LinkedList ARGUMENTS():
{
  	LinkedList<Term> list = new LinkedList<Term>();
	Term t1;
	LinkedList<Term > t2 = null;
}
{

	/* Arguments can be a term or a list of commas and terms */  
	( t1 = TERM() ) (<COMMA>  t2 = ARGUMENTS() )*

	{
	  if (t2 == null) 	  	list.add(t1);
	  else {
	  	list.add(t1);
	  	list.addAll(t2);
	  }
	  return list;	}

}

